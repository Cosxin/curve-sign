var config = {
  geojson: "./data/geoJSON_result.geojson",
  title: "Curve Sign Dashboard",
  layerNames: ["Signs"],
  hoverProperty: "designation",
  sortProperty: "curve_id",
  sortOrder: "desc",
};

var metaInfo =
    [
      {
        key: "County Name",
        value: "Dade County, GA"
      },
      {
        key: "Route Name",
        value: "SR301"
      },
      {
        key: "Starting Milepost",
        value: "4.1"
      },
      {
        key: "Ending Milepost",
        value: "6.9"
      },
      {
        key: "Generated By",
        value: "A Steele"
      },
      {
        key: "Lateral Friction Limit",
        value: "12.0"
      },
      {
        key: "Model Geometry",
        value: "Parabolic"
      },
      {
        key: "Global Offset",
        value: 0,

      }
    ]

var properties = [{
  value: "curve_id",
  label: "curve_id",
  table: {
    visible: true,
    sortable: true,
  },
  filter: {
    type: "integer"
  },
  info: false
},
{
  value: "sign_elevation",
  label: "sign elevation",
  table: {
    visible: false,
    sortable: true
  },
  filter: {
    type: "integer"
  },
  info: false
},
{
  value: "designation",
  label: "MUTCD code",
  table: {
    visible: true,
    sortable: true,
  },
  filter: {
    type: "string",
    input: "checkbox",
    vertical: true,
    multiple: true,
    operators: ["in", "not_in", "equal", "not_equal"],
    values: []
  }
},
{
  value: "old_lat",
  label: "original latitude",
  table: {
    visible: false,
    sortable: true
  }
},
{
  value: "old_lon",
  label: "original longitude",
  table: {
    visible: false,
    sortable: true
  }
},
{
  value: "current_lat",
  label: "current latitude",
  table: {
    visible: false,
    sortable: true
  }
},
{
  value: "current_lng",
  label: "current longitude",
  table: {
    visible: false,
    sortable: true
  }
},
{
  value: "inclination",
  label: "original curve c-slope",
  table: {
    visible: false,
    sortable: true
  },
  filter: {
    type: "string",
    input: "checkbox",
    vertical: true,
    multiple: true,
    values: []
  }
},
{
  value: "mile_post",
  label: "MP",
  table: {
    visible: true,
    sortable: true
  },
  filter: {
    type: "double"
  },
  info: false
},
{
  value: "pcmp",
  label: "curve pcmp",
  table: {
    visible: false,
    sortable: true
  },
  filter: {
    type: "string",
    input: "checkbox",
    vertical: true,
    multiple: true,
    values: []
  }
},
{
  value: "ptmp",
  label: "curve ptmp",
  table: {
    visible: false,
    sortable: true
  },
  filter: {
    type: "string",
    input: "checkbox",
    vertical: true,
    multiple: true,
    values: []
  }
},
{
  value: "custom_label",
  label: "Label",
  table: {
    visible: true,
    sortable: true,
    editable: true,
  },
  filter: {
    type: "string",
    input: "checkbox",
    vertical: true,
    multiple: true,
    values: []
  }
},
{
  value: "moved",
  label: "Changed",
  table: {
    visible: false,
    sortable: true
  },
  filter: {
    type: "string",
    input: "checkbox",
    vertical: true,
    multiple: true,
    values: []
  }
},
{
  value: "icon_url",
  label: "Icons",
  table: {
    visible: false,
    sortable: false,
    formatter: urlFormatter
  },
  filter: false
}
];

var signInfo = {
  signs: [
    {
      name: 'w1-1_L',
      descr: 'Left Turn',
    },
    {
      name: 'w1-1_R'
    },
    {
      name: 'w1-2_L'
    },
    {
      name: 'w1-2_R'
    },
    {
      name: 'w1-3_L'
    },
    {
      name: 'w1-3_R'
    },
    {
      name: 'w1-4_L'
    },
    {
      name: 'w1-4_R'
    },
    {
      name: 'w1-1_L',
      descr: 'Left Turn',
    },
    {
      name: 'w1-1_R'
    },
    {
      name: 'w1-2_L'
    },
    {
      name: 'w1-2_R'
    },
    {
      name: 'w1-3_L'
    },
    {
      name: 'w1-3_R'
    },
    {
      name: 'w1-4_L'
    },
    {
      name: 'w1-4_R'
    }]
}

$(function () {
  $(".title").html(config.title);
  config.layerNames.forEach(function (layerName, i) {
    $("#layer-name" + i).html(layerName);
  });
});

function buildConfig() {
  filters = [];
  table = [{
    field: "action",
    title: "<i class='fa fa-gear'></i>&nbsp;Action",
    align: "center",
    valign: "middle",
    width: "75px",
    cardVisible: false,
    switchable: false,
    formatter: function (value, row, index) {
      return [
        '<a class="zoom" href="javascript:void(0)" title="Zoom" style="margin-right: 10px;">',
        '<i class="fa fa-search-plus"></i>',
        '</a>',
        '<a class="identify" href="javascript:void(0)" title="Identify">',
        '<i class="fa fa-info-circle"></i>',
        '</a>'
      ].join("");
    },
    events: {
      "click .zoom": function (e, value, row, index) {
        map.fitBounds(featureLayer.getLayer(row.leaflet_stamp).getBounds());
        highlightLayer.clearLayers();
        highlightLayer.addData(featureLayer.getLayer(row.leaflet_stamp).toGeoJSON());
      },
      "click .identify": function (e, value, row, index) {
        identifyFeature(row.leaflet_stamp);
        highlightLayer.clearLayers();
        highlightLayer.addData(featureLayer.getLayer(row.leaflet_stamp).toGeoJSON());
      }
    }
  }];

  $.each(properties, function (index, value) {
    // Filter config
    if (value.filter) {
      var id;
      if (value.filter.type == "integer") {
        id = "cast(properties->" + value.value + " as int)";
      }
      else if (value.filter.type == "double") {
        id = "cast(properties->" + value.value + " as double)";
      }
      else {
        id = "properties->" + value.value;
      }
      filters.push({
        id: id,
        label: value.label
      });
      $.each(value.filter, function (key, val) {
        if (filters[index]) {
          // If values array is empty, fetch all distinct values
          if (key == "values" && val.length === 0) {
            alasql("SELECT DISTINCT(properties->" + value.value + ") AS field FROM ? ORDER BY field ASC", [geojson.features], function (results) {
              distinctValues = [];
              $.each(results, function (index, value) {
                distinctValues.push(value.field);
              });
            });
            filters[index].values = distinctValues;
          } else {
            filters[index][key] = val;
          }
        }
      });
    }
    // Table config
    if (value.table) {
      table.push({
        field: value.value,
        title: value.label
      });
      $.each(value.table, function (key, val) {
        if (table[index + 1]) {
          table[index + 1][key] = val;
        }
      });
    }
  });

  buildFilters();
  buildTable();
  buildSidebar();
}

var Esri_WorldStreetMap = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
  attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
});
var Esri_WorldImagery = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
  attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
});


var highlightLayer = L.geoJson(null, {
  pointToLayer: function (feature, latlng) {
    return L.circleMarker(latlng, {
      radius: 5,
      color: "#FFF",
      weight: 2,
      opacity: 1,
      fillColor: "#00FFFF",
      fillOpacity: 1,
      clickable: false
    });
  },
  style: function (feature) {
    return {
      color: "#00FFFF",
      weight: 2,
      opacity: 1,
      fillColor: "#00FFFF",
      fillOpacity: 0.5,
      clickable: false
    };
  }
});

var featureLayer = L.geoJson(null, {
  filter: function (feature, layer) {
    return feature.geometry.coordinates[0] !== 0 && feature.geometry.coordinates[1] !== 0;
  },
  pointToLayer: function (feature, feature_latlng) {
    var latlng =
        L.latLng(feature_latlng.lat + offset * feature.properties.outer_vector_lat,
                 feature_latlng.lng + offset * feature.properties.outer_vector_lon);
    if (feature.properties && feature.properties["marker-color"]) {
      markerColor = feature.properties["marker-color"];
    } else {
      markerColor = "#FF0000";
    }
    var icon = L.icon({
      iconUrl: feature.properties["icon_url"],
      iconSize: [25, 30]
    });
    var marker = L.marker(latlng, {
      icon: icon,
      draggable: true,
      opacity: 1,
    });
    var shadow_marker = new L.marker([feature.properties.old_lat, feature.properties.old_lon], {
      icon: icon,
      opacity: 0.2,
    });
    marker.on('drag', function (e) {
      shadow_marker.addTo(map);
    });
    marker.on('dragend', function (e) {
      marker.feature.properties.moved = true;
      shadow_marker.remove();
      syncTable();
    });
    return marker;
    /*
    return L.circleMarker(latlng, {
      radius: 4,
      weight: 2,
      fillColor: markerColor,
      color: markerColor,
      opacity: 1,
      fillOpacity: 1
    });
    */
  },
  onEachFeature: function (feature, layer) {
    if (feature.properties) {
      layer.on({
        click: function (e) {
          identifyFeature(L.stamp(layer));
          highlightLayer.clearLayers();
          highlightLayer.addData(featureLayer.getLayer(L.stamp(layer)).toGeoJSON());
        },
        mouseover: function (e) {
          if (config.hoverProperty) {
            $(".info-control").html(feature.properties[config.hoverProperty]);
            $(".info-control").show();
          }
        },
        mouseout: function (e) {
          $(".info-control").hide();
        }
      });
    }
  }
});


// Fetch the GeoJSON file
$.getJSON(config.geojson, function (data) {
  geojson = data;
  features = $.map(geojson.features, function (feature) {
    return feature.properties;
  });
  console.log(data);
  featureLayer.addData(data);
  buildConfig();
  $("#loading-mask").hide();
});

var map = L.map("map", {
  layers: [Esri_WorldStreetMap, featureLayer],
  preferCanvas: true
}).fitWorld();

// ESRI geocoder
var searchControl = L.esri.Geocoding.geosearch({
  useMapBounds: 17
}).addTo(map);

// Info control
var info = L.control({
  position: "bottomleft"
});

// Custom info hover control
info.onAdd = function (map) {
  this._div = L.DomUtil.create("div", "info-control");
  this.update();
  return this._div;
};
info.update = function (props) {
  this._div.innerHTML = "";
};
info.addTo(map);
$(".info-control").hide();


var offset = 0;

var slider = L.control.slider(function(value) {
    if(typeof features != "undefined")
    {
      console.log("moving features")
      offset = value / 1000;
      featureLayer.clearLayers();
      featureLayer.addData(geojson);
    }
},
    {id:slider, width: '300px',
  orientation: 'horizontal',min:-1, max:1, step:0.01, value: 0, offset: 'O'});
slider.addTo(map);

// Larger screens get expanded layer control
if (document.body.clientWidth <= 767) {
  isCollapsed = true;
} else {
  isCollapsed = false;
}
var baseLayers = {
  "Street Map": Esri_WorldStreetMap,
  "Aerial Imagery": Esri_WorldImagery
};
var overlayLayers = {
  "<span id='layer-name0'>GeoJSON Layer</span>": featureLayer,
};
var layerControl = L.control.layers(baseLayers, overlayLayers, {
  collapsed: isCollapsed
}).addTo(map);

var scaleBar = L.control.scale().addTo(map);

// Filter table to only show features in current map bounds
map.on("moveend", function (e) {
  if (!exporting) syncTable();
});

map.on("click", function (e) {
  highlightLayer.clearLayers();
});

// Table formatter to make links clickable
function urlFormatter(value, row, index) {
  if (typeof value == "string" && (value.indexOf("http") === 0 || value.indexOf("https") === 0)) {
    return "<a href='" + value + "' target='_blank'>" + value + "</a>";
  }
}

function buildFilters() {
  $("#query-builder").queryBuilder({
    allow_empty: true,
    filters: filters
  });
}

function applyFilter() {
  var query = "SELECT * FROM ?";
  var sql = $("#query-builder").queryBuilder("getSQL", false, false).sql;
  if (sql.length > 0) {
    query += " WHERE " + sql;
  }
  alasql(query, [geojson.features], function (features) {
    featureLayer.clearLayers();
    featureLayer.addData(features);
    syncTable();
  });
}

function buildTable() {
  $("#table").bootstrapTable({
    cache: false,
    height: $("#table-container").height(),
    undefinedText: "",
    striped: false,
    pagination: false,
    minimumCountColumns: 1,
    sortName: config.sortProperty,
    sortOrder: config.sortOrder,
    toolbar: "#toolbar",
    search: true,
    trimOnSearch: false,
    showColumns: true,
    showToggle: true,
    columns: table,
    scrollX: true,
    onClickRow: function (row) {
      // do something!
    },
    onDblClickRow: function (row) {
      map.panTo(new L.LatLng(row.current_lat, row.current_lng));
      // do something!
    }
  });

  map.fitBounds(featureLayer.getBounds(),
    {
      animate: false,
    });

  $(window).resize(function () {
    $("#table").bootstrapTable("resetView", {
      height: $("#table-container").height()
    });
  });
}

function syncTable() {
  tableFeatures = [];
  featureLayer.eachLayer(function (layer) {
    layer.feature.properties.leaflet_stamp = L.stamp(layer);
    layer.feature.properties.current_lat = layer.getLatLng().lat;
    layer.feature.properties.current_lng = layer.getLatLng().lng;
    if (map.hasLayer(featureLayer)) {
      if (map.getBounds().contains(layer.getLatLng())) {
        //TODO: Not working if mix feature types in single geojson file
        tableFeatures.push(layer.feature.properties);
      }
    }
  });

  $("#table").bootstrapTable("load", JSON.parse(JSON.stringify(tableFeatures)));
  var featureCount = $("#table").bootstrapTable("getData").length;
  if (featureCount == 1) {
    $("#feature-count").html($("#table").bootstrapTable("getData").length + " visible feature");
  } else {
    $("#feature-count").html($("#table").bootstrapTable("getData").length + " visible features");
  }
}
function resetMarker(id) {
  var layer = featureLayer.getLayer(id);
  layer.setLatLng([layer.feature.properties.old_lat, layer.feature.properties.old_lon]);
  syncTable();
}
function deleteMarker(id) {
  featureLayer.removeLayer(id);
  syncTable();
}
function identifyFeature(id) {
  var featureProperties = featureLayer.getLayer(id).feature.properties;
  var content = "<table class='table table-striped table-bordered table-condensed'>";
  $("#resetMarker").off("click").on("click", function () { resetMarker(id); });
  $("#deleteMarker").off("click").on("click", function () { deleteMarker(id); });
  $.each(featureProperties, function (key, value) {
    if (!value) {
      value = "";
    }
    if (typeof value == "string" && (value.indexOf("http") === 0 || value.indexOf("https") === 0)) {
      value = "<a href='" + value + "' target='_blank'>" + value + "</a>";
    }
    $.each(properties, function (index, property) {
      if (key == property.value) {
        if (property.info !== false) {
          content += "<tr><th>" + property.label + "</th><td>" + value + "</td></tr>";
        }
      }
    });
  });
  content += "<table>";
  $("#feature-info").html(content);
  $("#featureModal").modal("show");
}


function buildSidebar() {
  signInfo.signs.forEach(function (sign) {
    $("#sidebar-signs-container").append("<div class='card'> <img class='card-img-top'" +
      "src='./assets/images/" + sign.name + ".png' height='50px' alt='Card image'> <div class='card-body'>" +
      "<h5 class='card-title'>" + sign.name + "</h5></div></div>")
  }
  );
}
/*
  Register button callback functions
*/

$(function () {
  addClickEvents();
  addDropEvents();
})

function switchView(view) {
  if (view == "split") {
    $("#view").html("Split View");
    location.hash = "#split";
    $("#table-container").show();
    $("#table-container").css("height", "55%");
    $("#map-container").show();
    $("#map-container").css("height", "45%");
    $(window).resize();
    if (map) {
      map.invalidateSize();
    }
  } else if (view == "map") {
    $("#view").html("Map View");
    location.hash = "#map";
    $("#map-container").show();
    $("#map-container").css("height", "100%");
    $("#table-container").hide();
    if (map) {
      map.invalidateSize();
    }
  } else if (view == "table") {
    $("#view").html("Table View");
    location.hash = "#table";
    $("#table-container").show();
    $("#table-container").css("height", "100%");
    $("#map-container").hide();
    $(window).resize();
  }
}


function addClickEvents() {
  $("[name='view']").click(function () {
    $(".in,.open").removeClass("in open");
    if (this.id === "map-graph") {
      switchView("split");
      return false;
    } else if (this.id === "map-only") {
      switchView("map");
      return false;
    } else if (this.id === "graph-only") {
      switchView("table");
      return false;
    }
  });

  $("#filter-btn").click(function () {
    $("#filterModal").modal("show");
    $(".navbar-collapse.in").collapse("hide");
    return false;
  });

  $("#total-btn").click(function () {
    $("#totalModal").modal("show");
    $(".navbar-collapse.in").collapse("hide");
    return false;
  });

  $("#view-sql-btn").click(function () {
    alert($("#query-builder").queryBuilder("getSQL", false, false).sql);
  });

  $("#apply-filter-btn").click(function () {
    applyFilter();
  });

  $("#reset-filter-btn").click(function () {
    $("#query-builder").queryBuilder("reset");
    applyFilter();
  });

  $("#extent-btn").click(function () {
    map.fitBounds(featureLayer.getBounds());
    $(".navbar-collapse.in").collapse("hide");
    return false;
  });

  $("#download-csv-btn").click(function () {
    $("#table").tableExport({
      type: "csv",
      ignoreColumn: [0],
      fileName: "data"
    });
    $(".navbar-collapse.in").collapse("hide");
    return false;
  });

  $("#download-excel-btn").click(function () {
    $("#table").tableExport({
      type: "excel",
      ignoreColumn: [0],
      fileName: "data"
    });
    $(".navbar-collapse.in").collapse("hide");
    return false;
  });

  $("#download-pdf-btn").click(function () {
    var doc = new jspdf.jsPDF();
    var data = ($('#signTotalTable').bootstrapTable('getData'));
    console.log(data);

    doc.setFontSize(22);
    doc.text("Curve Sign Analysis Report", doc.internal.pageSize.getWidth()/2, 15, {align:'center'} );

    doc.setFontSize(18);
    doc.text("Georgia Institute of Technology", doc.internal.pageSize.getWidth()/2, 25, {align:'center'} );

    doc.setFontSize(15);
    doc.text('Metadata', 14, 40);
    doc.autoTable({
      startY: 45,
      html: '#metaTotalTable',
    });

    doc.text('Total Sign Inventory', 14, doc.lastAutoTable.finalY + 15);
    doc.autoTable({
      startY: doc.lastAutoTable.finalY + 15 + 5,
      html: '#signTotalTable',
      didDrawCell: function (data) {
        if (data.column.index == 1 && data.cell.section == 'body') {
          var td = data.cell.raw;
          var img = td.getElementsByTagName('img')[0];
          var dim = data.cell.height;
          doc.addImage(img.src, 'PNG', data.cell.x, data.cell.y, dim, dim);
        }
      }
    });

    doc.text('Total signs needed for each curve', 14, doc.lastAutoTable.finalY + 15);
    doc.autoTable({
      startY: doc.lastAutoTable.finalY + 15 + 5,
      html: '#curveTotalTable',
      showHead: 'firstPage',
    })
    doc.save('table.pdf');
  });

  $("#download-geojson-btn").click(function () {
    var file = new File([JSON.stringify(featureLayer.toGeoJSON())], "download.geojson", { type: "Content-type: application/json;" });
    saveAs(file);
    $(".navbar-collapse.in").collapse("hide");
    return false;
  });

  $("#download-maps-btn").click(function () {
    var results = alasql('Select *, MAX(current_lng) as maxlon, MIN(current_lng) as minlon, MAX(current_lat) as maxlat, ' +
      'MIN(current_lat) as minlat from ? Group by curve_id', [features]);
    imgs = [];
    curveIDs = [];
    exporting = true;
    $("#exportingModal").modal({ backdrop: 'static', keyboard: false });

    function mapToImage(i) {
      if (i >= results.length) {
        $("#exportingModal").modal("close");
        exporting = false;
        return;
      }
      var curve = results[i];
      map.fitBounds(L.latLngBounds(L.latLng(curve.maxlat, curve.maxlon), L.latLng(curve.minlat, curve.minlon)));
      leafletImage(map, function (err, canvas) {
        // now you have canvas
        // example thing to do with that canvas:
        imgs.push(canvas.toDataURL());
        curveIDs.push(curve.curve_id);
        mapToImage(i + 1)
        //document.getElementById('images').innerHTML = '';
        //document.getElementById('images').appendChild(img);
      });
    }
    mapToImage(0);

  });

  $("#totalModal").on("shown.bs.modal", function (e) {
    generateTotals();
  });
}

/*
  Functions to support Drag-n-Drop GeoJSON
 */


function addDropEvents() {
  // set up the drag & drop events
  var mapContainer = document.getElementById('map-container');
  var dropContainer = document.getElementById('drop-container');

  // map-specific events
  mapContainer.addEventListener('dragenter', showPanel, false);

  // overlay specific events (since it only appears once drag starts)
  dropContainer.addEventListener('dragover', showPanel, false);
  dropContainer.addEventListener('drop', handleDrop, false);
  dropContainer.addEventListener('dragleave', hidePanel, false);
}

function showPanel(e) {
  e.stopPropagation();
  e.preventDefault();
  document.getElementById('drop-container').style.display = 'block';
  return false;
}

function hidePanel(e) {
  document.getElementById('drop-container').style.display = 'none';
}

function loadGeoJsonString(geoString) {
  var geojson = JSON.parse(geoString);
  featureLayer.clearLayers();
  features = $.map(geojson.features, function (feature) {
    return feature.properties;
  });
  featureLayer.addData(geojson);
  buildConfig();
  generateTotals();
  $("#loading-mask").hide();
}

function handleDrop(e) {
  e.preventDefault();
  e.stopPropagation();
  hidePanel(e);

  var files = e.dataTransfer.files;

  if (files.length) {
    // process file(s) being dropped
    // grab the file data from each file
    for (var i = 0, file; file = files[i]; i++) {
      var reader = new FileReader();
      reader.onload = function (e) {
        loadGeoJsonString(e.target.result);
      };
      reader.onerror = function (e) {
        console.error('reading failed');
      };
      reader.readAsText(file);
    }
  } else {
    // process non-file (e.g. text or html) content being dropped
    // grab the plain text version of the data
    var plainText = e.dataTransfer.getData('text/plain');
    if (plainText) {
      loadGeoJsonString(plainText);
    }
  }

  // prevent drag event from bubbling further
  return false;
}





// Generate Total After LoadGeoJSON is complete

var reset = false;
exporting = false;

var generateTotals = function() {
  //metadata
  $("#metaTotalTable").bootstrapTable({
    columns: [{
      field: 'key',
      title: 'Key'
    }, {
      field: 'value',
      title: 'Value'
    }
    ],
    data: metaInfo,
    showColumns: true,
  })


  //by curve
  $(function () {
    /*var result = alasql("SELECT * from", [features]);
    var data = $.map(result, function (status) {
      return {
        id: status.curve_id,
        code: status.sign_code,
        count: status.Quantity,
        required: status.required
      };
    });*/
    $("#curveTotalTable").bootstrapTable({
      columns: [{
        field: 'curve_id',
        title: 'Curve ID',
        width: 50,
        align: 'center'
      }, {
        field: 'route_direction',
        title: 'Curve Direction',
        align: 'center'
      }, {
        field: 'pcmp',
        title: 'PC Location',
        align: 'center'
      },{
        field: 'designation',
        title: 'Sign Type',
        align: 'center'
      },{
        field: 'road_side',
        title: 'Side of Curve',
        align: 'center'
      },{
        field: 'face',
        title: 'Facing',
        align: 'center'
      },
      {
        field: 'distance_from_pc',
        title: 'Distance to PC',
        align: 'center'
      },
      {
        field: 'mile_post',
        title: 'Milepost',
        align: 'center'
      },
      {
        field: 'required',
        title: 'Required',
        align: 'center'
      }
      ],
      data: features,
      groupBy: true,
      groupByField: 'curve_id',
      groupByFormatter: function(value, i, data){return "Curve: " + value + " | " + "Sign Counts: " + data.length;},
      showColumns: true,
    })
  });

  //by sign
  $(function () {
    var result = alasql("SELECT sign_code as Sign, COUNT(*) AS Quantity FROM ? GROUP BY sign_code", [features]);
    console.log(result);
    var data = $.map(result, function (sign) {
      return {
        Sign: sign.Sign,
        Image: "<img class='card-img-top'" + "src='./assets/images/" + sign.Sign + ".png' height= '50px' alt='Card image'>",
        Quantity: sign.Quantity,
      }
    });
    $("#signTotalTable").bootstrapTable({
      columns: [{
        field: 'Sign',
        title: "Sign",
      }, {
        field: 'Image',
        title: 'Image',
      }, {
        field: 'Quantity',
        title: 'Quantity',
      }],
      data: data,
      showColumns: true,
    })
  });
};